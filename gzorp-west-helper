#!/usr/bin/env python3

import sys
import subprocess
import re
import threading
import queue
import yaml
import os
import hashlib
from datetime import datetime
from typing import Dict, List, TextIO, TypedDict

# Check for the environment variable to enable debug mode
DEBUG = os.getenv('GZORP_DEBUG', 'false').lower() in ['1', 'true', 'yes']


def debug_print(msg: str) -> None:
    if DEBUG:
        print(f"[DEBUG] {msg}")


CONFIG_DIR = os.path.expanduser('~/.config/gzorp-west-helper')
PATTERN_DIR = os.path.join(CONFIG_DIR, 'patterns')
PATTERN_FILE = os.path.join(PATTERN_DIR, 'zephyr.yaml')
PENDING_RESOLUTION_FILE = os.path.join(PATTERN_DIR, 'zephyr-pending-resolution.yaml')

# TODO: Create PENDING_RESOLUTION_FILE if it does not exist

# TODO Rename the existing pending resolution file to [date-time]-zephyr-pending-resolution.yaml


def rename_existing_pending_resolution_file():
    debug_print(f"Looking for existing pending resolution file {PENDING_RESOLUTION_FILE}")
    if os.path.exists(PENDING_RESOLUTION_FILE):
        debug_print(f"Found existing pending resolution file {PENDING_RESOLUTION_FILE}")
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        debug_print(f"New name for pending resolution file: zephyr-pending-resolution.yaml-{timestamp}")
        new_name = f"{PENDING_RESOLUTION_FILE}-{timestamp}"
        os.rename(PENDING_RESOLUTION_FILE, new_name)
        debug_print(f"Renamed existing pending resolution file to {new_name}")


class ErrorPattern(TypedDict):
    message: str
    resolution: List[str]
    pattern: str


def load_error_patterns() -> Dict[str, ErrorPattern]:
    patterns = {}
    if os.path.exists(PATTERN_FILE):
        try:
            with open(PATTERN_FILE, 'r') as f:
                patterns = yaml.safe_load(f)
            debug_print(f"Loaded patterns from {PATTERN_FILE}")
        except (yaml.YAMLError, FileNotFoundError) as e:
            debug_print(f"Error loading {PATTERN_FILE}: {e}")
    return patterns


def save_error_patterns(patterns: Dict[str, ErrorPattern], filepath: str) -> None:
    try:
        with open(filepath, 'w') as f:
            yaml.dump(patterns, f, default_flow_style=False)
        debug_print(f"Saved patterns to {filepath}")
    except Exception as e:
        debug_print(f"Error saving to {filepath}: {e}")


def hash_string(s: str) -> str:
    return hashlib.md5(s.encode()).hexdigest()


ERROR_PATTERNS = load_error_patterns()

# Flag to track if any pattern was matched
pattern_matched = False

# Define the patterns to ignore
DO_NOT_PASS_THRU_PATTERNS = [
    re.compile(r"Serial port /dev/ttyS\d+"),
    re.compile(r"/dev/ttyS\d+ failed to connect: Could not open /dev/ttyS\d+, the port is busy or doesn't exist."),
    re.compile(r"\(Could not configure port: \(5, 'Input/output error'\)\)")
]

# Watch a stream for output and check for known error patterns


def stream_watcher(stream: TextIO, prefix: str, message_queue: queue.Queue) -> None:
    global pattern_matched
    try:
        for line in iter(stream.readline, ''):
            line = line.rstrip()

            # Check if the line matches any of the ignore patterns
            if any(pattern.match(line) for pattern in DO_NOT_PASS_THRU_PATTERNS):
                continue

            # Only output the line if it is not empty
            if line:
                if prefix == 'stderr':
                    sys.stderr.write('\x1b[38;5;208m' + line + '\x1b[0m' + '\n')
                else:
                    sys.stdout.write(line + '\n')

            # Check for matching patterns
            for pattern_name, pattern in ERROR_PATTERNS.items():
                if re.search(pattern['pattern'], line):
                    pattern_matched = True
                    message_queue.put((pattern_name, pattern))
                    break
    except Exception as e:
        debug_print(f"Error in stream_watcher: {e}")


# Don't recall if this is working to ignore the esp specific 'make monitor' errors
def filter_output(line):
    exclude_patterns = ['_WindowOverflow4', '_stext at ??:?']  # These are errors that to be ignored according to Espressif
    return not any(pattern in line for pattern in exclude_patterns)


def main():
    global pattern_matched
    message_queue = queue.Queue()

    # Check if the command starts with "west build -b" or "west flash"
    if len(sys.argv) > 1 and (sys.argv[1] == 'build' and sys.argv[2] == '-b' or sys.argv[1] == 'flash'):
        # Run the west command
        process = subprocess.Popen(['west'] + sys.argv[1:], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Start stream watchers for stdout and stderr
        stdout_thread = threading.Thread(target=stream_watcher, args=(process.stdout, 'stdout', message_queue))
        stderr_thread = threading.Thread(target=stream_watcher, args=(process.stderr, 'stderr', message_queue))
        stdout_thread.start()
        stderr_thread.start()

        # Wait for the process to complete
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        # Process messages from the queue
        new_patterns = {}
        while not message_queue.empty():
            pattern_name, pattern = message_queue.get()
            if pattern_name == 'unmatched_error':
                # Use a hash of the error string as the top-level key
                error_hash = hash_string(pattern)
                # Add unmatched error to new patterns
                new_patterns[error_hash] = {
                    'pattern': pattern,  # Store the pattern verbatim
                    'message': 'Unmatched build error',
                    'resolution': [f'Resolution verification pending: {pattern}']
                }
                break  # Stop further processing after the first unmatched error
            else:
                if filter_output(pattern['message']):
                    print(f"Matched pattern: {pattern_name}")
                    print(f"Message: {pattern['message']}")
                    print(f"Resolution: {pattern['resolution']}")

        # Save new patterns to zephyr-pending-resolution.yaml
        if new_patterns:
            # Rename existing pending resolution file if DEBUG is True
            if DEBUG:
                rename_existing_pending_resolution_file()

            # Load existing pending resolutions
            if os.path.exists(PENDING_RESOLUTION_FILE):
                try:
                    with open(PENDING_RESOLUTION_FILE, 'r') as f:
                        existing_patterns = yaml.safe_load(f) or {}
                except (yaml.YAMLError, FileNotFoundError) as e:
                    debug_print(f"Error loading {PENDING_RESOLUTION_FILE}: {e}")
                    existing_patterns = {}
            else:
                existing_patterns = {}

            # Update with new patterns
            existing_patterns.update(new_patterns)
            save_error_patterns(existing_patterns, PENDING_RESOLUTION_FILE)

        # Print a message if no patterns were matched
        if not pattern_matched:
            print("\033[95mgzorp-west-helper:\033[0m No matching pattern found for the current build error.")
    else:
        # If the command does not start with "west build -b", run the command directly
        subprocess.run(['west'] + sys.argv[1:], check=True)


if __name__ == "__main__":
    main()
