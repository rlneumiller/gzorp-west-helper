#!/usr/bin/env python3

import sys
import subprocess
import re
import threading
import queue
from typing import Dict, List, TextIO

DEBUG = True

ERROR_PATTERNS: Dict[str, Dict[str, List[str]]] = {
    r'__device_dts_ord_DT_N_ALIAS_i2c': {
        'message': 'I2C device support not configured',
        'configs': [
            'CONFIG_I2C=y',
            'CONFIG_I2C_STM32=y'
        ]
    },
    r'undefined reference to.*gpio': {
        'message': 'GPIO support not configured',
        'configs': ['CONFIG_GPIO=y']
    }
}

def debug_print(msg: str) -> None:
    if DEBUG:
        print(f"[DEBUG] {msg}")
        
# Watch a stream for output and check for known error patterns
def stream_watcher(stream: TextIO, prefix: str, message_queue: queue.Queue) -> None:
    try:
        for line in iter(stream.readline, ''):
            line = line.rstrip()
            
            if prefix == 'stderr':
                if DEBUG:
                    sys.stderr.write('stderr:passthru: ' + line + '\n')
                else:
                    sys.stderr.write(line + '\n')
                    
                sys.stderr.flush()
                
                # Check for known error patterns
                for pattern, solution in ERROR_PATTERNS.items():
                    if re.search(pattern, line):
                        debug_print(f"Found pattern: {pattern}")
                        message_queue.put((pattern, solution))
            else:
                if DEBUG:
                    sys.stdout.write('stdout:passthru: ' + line + '\n')
                else:
                    sys.stdout.write(line + '\n')
                    
                sys.stdout.flush()
                
                # Check for known error patterns
                for pattern, solution in ERROR_PATTERNS.items():
                    if re.search(pattern, line):
                        debug_print(f"Found pattern: {pattern}")
                        message_queue.put((pattern, solution))
                
    finally:
        stream.close()

def monitor_process(args: List[str]) -> int:
    message_queue = queue.Queue()
    debug_print(f"Monitoring process: {' '.join(args)}")
    
    process = subprocess.Popen(
        args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1
    )

    stdout_thread = threading.Thread(
        target=stream_watcher, 
        args=(process.stdout, 'stdout', message_queue)
    )
    stderr_thread = threading.Thread(
        target=stream_watcher, 
        args=(process.stderr, 'stderr', message_queue)
    )
    
    stdout_thread.daemon = True
    stdout_thread.start()
    stderr_thread.daemon = True
    stderr_thread.start()

    process.wait()
    
    # Process error messages
    if not message_queue.empty():
        print("\n[WEST-HELPER] Build errors detected:")
        seen_patterns = set()
        while not message_queue.empty():
            pattern, solution = message_queue.get()
            if pattern not in seen_patterns:
                print(f"\n[WEST-HELPER] {solution['message']}")
                print("[WEST-HELPER] Add to prj.conf:")
                for config in solution['configs']:
                    print(f"[WEST-HELPER]   {config}")
                seen_patterns.add(pattern)
        print()
    
    stdout_thread.join()
    stderr_thread.join()
   
    return process.returncode


if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1] != "build":
        subprocess.run(["west"] + sys.argv[1:])
    else:
        sys.exit(monitor_process(["west"] + sys.argv[1:]))