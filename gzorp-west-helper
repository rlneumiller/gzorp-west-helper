#!/usr/bin/env python3

import sys
import subprocess
import re
import threading
import queue
import yaml
import os
from typing import Dict, List, TextIO

DEBUG = True

def debug_print(msg: str) -> None:
    if DEBUG:
        print(f"[DEBUG] {msg}")

CONFIG_DIR = os.path.expanduser('~/.config/gzorp-west-helper')
CONFIG_PATH = os.path.join(CONFIG_DIR, 'devicetree_error_patterns.yaml')

def load_error_patterns() -> Dict:
    try:
        with open(CONFIG_PATH, 'r') as f:
            patterns = yaml.safe_load(f)
        debug_print(f"Loaded {len(patterns)} error patterns from {CONFIG_PATH}")
        return patterns
    except FileNotFoundError:
        debug_print(f"No config file found at {CONFIG_PATH}, using empty patterns")
        return {}
    except yaml.YAMLError as e:
        debug_print(f"Error parsing {CONFIG_PATH}: {e}")
        return {}

def save_error_patterns(patterns: Dict) -> None:
    try:
        with open(CONFIG_PATH, 'w') as f:
            yaml.dump(patterns, f, default_flow_style=False)
        debug_print(f"Saved {len(patterns)} error patterns to {CONFIG_PATH}")
    except Exception as e:
            debug_print(f"Error saving patterns to {CONFIG_PATH}: {e}")


ERROR_PATTERNS = load_error_patterns()
        
# Watch a stream for output and check for known error patterns
def stream_watcher(stream: TextIO, prefix: str, message_queue: queue.Queue) -> None:
    try:
        for line in iter(stream.readline, ''):
            line = line.rstrip()
            
            if prefix == 'stderr':
                if DEBUG:
                    sys.stderr.write('stderr:passthru: ' + line + '\n')
                else:
                    sys.stderr.write(line + '\n')
                    
                sys.stderr.flush()
                
                # Check for known error patterns
                for pattern, solution in ERROR_PATTERNS.items():
                    if re.search(pattern, line):
                        debug_print(f"Found pattern: {pattern}")
                        message_queue.put((pattern, solution))
            else:
                if DEBUG:
                    sys.stdout.write('stdout:passthru: ' + line + '\n')
                else:
                    sys.stdout.write(line + '\n')
                    
                sys.stdout.flush()
                
                # Check for known error patterns
                for pattern, solution in ERROR_PATTERNS.items():
                    if re.search(pattern, line):
                        debug_print(f"Found pattern: {pattern}")
                        message_queue.put((pattern, solution))
                
    finally:
        stream.close()

def monitor_process(args: List[str]) -> int:
    message_queue = queue.Queue()
    debug_print(f"Monitoring process: {' '.join(args)}")
    
    process = subprocess.Popen(
        args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1
    )

    stdout_thread = threading.Thread(
        target=stream_watcher, 
        args=(process.stdout, 'stdout', message_queue)
    )
    stderr_thread = threading.Thread(
        target=stream_watcher, 
        args=(process.stderr, 'stderr', message_queue)
    )
    
    stdout_thread.daemon = True
    stdout_thread.start()
    stderr_thread.daemon = True
    stderr_thread.start()

    process.wait()
    
    # Process error messages
    if not message_queue.empty():
        print("\n[WEST-HELPER] Build errors detected:")
        seen_patterns = set()
        while not message_queue.empty():
            pattern, solution = message_queue.get()
            if pattern not in seen_patterns:
                print(f"\n[WEST-HELPER] {solution['message']}")
                print("[WEST-HELPER] Add to prj.conf:")
                for config in solution['configs']:
                    print(f"[WEST-HELPER]   {config}")
                seen_patterns.add(pattern)
        print()
    
    stdout_thread.join()
    stderr_thread.join()
   
    return process.returncode


if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1] != "build":
        subprocess.run(["west"] + sys.argv[1:])
    else:
        sys.exit(monitor_process(["west"] + sys.argv[1:]))